//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

public class PathSearch : MonoBehaviour
{
	TDTile [] _tileNodeList;
	Heuristic myHeuristic;
	int mapSize;
	List<TDTile> closedSet;
	TileNodePriorityQueue openSet;
	TDTile goalTile;

	public PathSearch()
	{
        // Because this class is inheritaning from MonoBehavior, Start() will be the constructor
	}

    void Start()
    {
        //TGMap tempMap = (TGMap)FindObjectOfType(typeof(TGMap));
        //_tileNodeList = tempMap.tileDataMap.Tiles;
        mapSize = -1;
        myHeuristic = new Heuristic ();
    }

    public void SetTileNodeList(TDTile[] nodeList, int size)
    {
        _tileNodeList = nodeList;
        mapSize = size;
    }

    public List<TDTile> GetSolution(/*Character.FRIENDFOE friendFoe*/)
    {
        List<TDTile> solution = new List<TDTile>();
        TDTile currTile = goalTile;

        //if (friendFoe == Character.FRIENDFOE.FOE)
        //    currTile = currTile.ParentTDTile;

        while (currTile != null)
        {
            if (currTile.IsTraversable)
                solution.Add(currTile);
            currTile = currTile.ParentTDTile;
        }

        solution.Reverse();
        return solution;
    }

    public void AStar(TDTile start, TDTile goal)
	{
        if (mapSize == -1)
            return;

		goalTile = goal;
		closedSet = new List<TDTile> ();
		openSet = new TileNodePriorityQueue ();
		start.ParentTDTile = null;
		openSet.Engueue (start);
		myHeuristic.SetGoal(goalTile);

		start.GValue = 0;
		start.FValue = start.GValue + myHeuristic.EstimateDistance (start, goal);

		while(!openSet.Empty())
		{
			TDTile current = openSet.Dequeue();

			if(current == goalTile)
				break;

			closedSet.Add(current);

			CheckAdjacents(current.Index - 1, current);
			CheckAdjacents(current.Index + mapSize, current);
			CheckAdjacents(current.Index + 1, current);
			CheckAdjacents(current.Index - mapSize, current);
		}
	}

	void CheckAdjacents(int successorIndex, TDTile current)
	{
		if(successorIndex >= 0 && successorIndex < _tileNodeList.Count())
		{
			bool isAdjacentTileRowAbove = (current.Index % mapSize == mapSize -1) && (successorIndex % mapSize == 0);
			bool isAdjacentTileRowBelow = (current.Index % mapSize == 0) && (successorIndex % mapSize == mapSize - 1);

			if(!isAdjacentTileRowAbove && !isAdjacentTileRowBelow)
			{
				TDTile successor = _tileNodeList[successorIndex];
				if(!closedSet.Contains(successor) && (successor == goalTile || successor.IsTraversable))
				{
					int tempGValue = 1; // If i want diagonal then this will need to be 1.4 for diagonals and 1 for straights

					if(!openSet.Contains(successor) || tempGValue < successor.GValue)
					{
						successor.ParentTDTile = current;
						successor.GValue = tempGValue;
						successor.FValue = tempGValue + myHeuristic.EstimateDistance(successor); // heuristic cost?

						if(!openSet.Contains(successor))
						{
							openSet.Engueue(successor);
						}
					}
				}
			}
		}
	}
}