//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
 

public class PathSearch : MonoBehaviour
{
    enum HeightAccessibility { TOO_HIGH, REACHABLE, INVALID_TILE }

	TDTile [] _tileNodeList;
	Heuristic myHeuristic;
	int mapSize;
	List<TDTile> closedSet;
	TileNodePriorityQueue openSet;
	TDTile goalTile;

    public float tileHeightStep = 0.5f;

	public PathSearch()
	{
		// Because this class is inheritaning from MonoBehavior, Start() will be the constructor
	}

	void Start()
	{
		//TGMap tempMap = (TGMap)FindObjectOfType(typeof(TGMap));
		//_tileNodeList = tempMap.tileDataMap.Tiles;
		if(mapSize == 0)
			mapSize = -1;
		myHeuristic = new Heuristic ();
	}

	public void SetTileNodeList(TDTile[] nodeList, int size)
	{
		_tileNodeList = nodeList;
		mapSize = size;
	}

	public List<TDTile> GetSolution(/*Character.FRIENDFOE friendFoe*/)
	{
		List<TDTile> solution = new List<TDTile>();

        if (goalTile.ParentTDTile == null)
            return solution;

		TDTile currTile = goalTile;

		//if (friendFoe == Character.FRIENDFOE.FOE)
		//    currTile = currTile.ParentTDTile;

		while (currTile != null)
		{
			if (currTile.IsTraversable)
				solution.Add(currTile);
			currTile = currTile.ParentTDTile;
		}

		solution.Reverse();
		return solution;
	}

	public void AStar(TDTile start, TDTile goal)
	{
		if (mapSize == -1)
			return;

		goalTile = goal;
		closedSet = new List<TDTile> ();
		openSet = new TileNodePriorityQueue ();
		start.ParentTDTile = null;
		openSet.Engueue (start);
		myHeuristic.SetGoal(goalTile);

		start.GValue = 0;
		start.FValue = start.GValue + myHeuristic.EstimateDistance (start, goal);

        if(IsTileAccessible(goalTile.Index - 1) != HeightAccessibility.REACHABLE &&
            IsTileAccessible(goalTile.Index + 1) != HeightAccessibility.REACHABLE &&
            IsTileAccessible(goalTile.Index + mapSize) != HeightAccessibility.REACHABLE &&
            IsTileAccessible(goalTile.Index - mapSize) != HeightAccessibility.REACHABLE)
        {
            goalTile.IsTraversable = false;
        }

		while(!openSet.Empty())
		{
			TDTile current = openSet.Dequeue();

			if(current == goalTile)
				break;

			closedSet.Add(current);

			CheckAdjacents(current.Index - 1, current);
			CheckAdjacents(current.Index + mapSize, current);
			CheckAdjacents(current.Index + 1, current);
			CheckAdjacents(current.Index - mapSize, current);
		}
	}

	void CheckAdjacents(int successorIndex, TDTile current)
	{
		if(successorIndex >= 0 && successorIndex < _tileNodeList.Count())
		{
			bool isAdjacentTileRowAbove = (current.Index % mapSize == mapSize -1) && (successorIndex % mapSize == 0);
			bool isAdjacentTileRowBelow = (current.Index % mapSize == 0) && (successorIndex % mapSize == mapSize - 1);

			if(!isAdjacentTileRowAbove && !isAdjacentTileRowBelow)
			{
				TDTile successor = _tileNodeList[successorIndex];
				if(!closedSet.Contains(successor) && (successor == goalTile || successor.IsTraversable))
				{
                    float tempGValue = 1.0f; // If diagonal tiles are implemented, this will be either 1.0f for straight on tiles or 1.4f for diagonal

                    if (successor.Pos.y > current.Pos.y && successor != goalTile)
                    {
                        if (successor.Pos.y > current.Pos.y + tileHeightStep)
                        {
                            return;
                        }
                        else
                        {
                            tempGValue = 1.4f;
                        }
                    }

                    if (!openSet.Contains(successor) || tempGValue < successor.GValue)
					{
						successor.ParentTDTile = current;
						successor.GValue = tempGValue;
						successor.FValue = tempGValue + (float)myHeuristic.EstimateDistance(successor);

						if(!openSet.Contains(successor))
						{
							openSet.Engueue(successor);
						}
					}
				}
			}
		}
	}

    // Checks to see if the goaltile has any tiles adjacent to it that are of proper height to climb up to it
    HeightAccessibility IsTileAccessible(int adjacentTileIndex)
    {
        bool isAdjacentTileRowAbove = (goalTile.Index % mapSize == mapSize - 1) && (adjacentTileIndex % mapSize == 0);
        bool isAdjacentTileRowBelow = (goalTile.Index % mapSize == 0) && (adjacentTileIndex % mapSize == mapSize - 1);

        if(!isAdjacentTileRowAbove && !isAdjacentTileRowBelow && adjacentTileIndex >= 0)
        {
            if (goalTile.Pos.y - tileHeightStep > _tileNodeList[adjacentTileIndex].Pos.y)
                return HeightAccessibility.TOO_HIGH;
            else
                return HeightAccessibility.REACHABLE;
        }
        else
        {
            return HeightAccessibility.INVALID_TILE;
        }
    }
}